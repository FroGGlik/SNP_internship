'''
Напишите декоратор @cached, который кэширует результаты функции, чтобы
избежать повторных вычислений для одних и тех же аргументов. Декоратор
должен поддерживать:

• ограничение размера кэша: при превышении максимально хранимого
количества записей (max_size) удаляются самые старые записи:
• если max_size=None, то размер кэша не ограничен
• если max_size не соответствует целому числу, то также
инициализировать его как None
• время жизни записей: автоматически удалять результаты, сохранённые
более seconds назад:
• если seconds=None, то записи не устаревают
• размер кэша не ограничен, если seconds не соответствует целому
числу, то также инициализировать его как None
• декоратор должен учитывать как позиционные (*args), так и
именованные аргументы (**kwargs)

Тесты для примеров и проверки:
@cached(max_size=3, seconds=10)
def slow_function(x):
print(f"Вычисляю для {x}...")
return x ** 2
# Первый вызов — вычисляется
print(slow_function(2)) # Вывод: "Вычисляю для 2..." → 4
# Повторный вызов с теми же аргументами — берётся из кэша
print(slow_function(2)) # Вывод: 4 (без вычисления)
# Через 15 секунд кэш устареет, и будет новое вычисление
time.sleep(15)  
print(slow_function(2)) # Вывод: "Вычисляю для 2.   .." → 4
'''

def cahced(max_size: None, seconds: int):
    def decorator(func):
        def wrapper():
            ...
        
        return wrapper