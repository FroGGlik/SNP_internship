'''
Задание является не обязательным, но его выполнение поможет лучше
ознакомиться с итераторами.
Реализовать класс BlockTranspositionCipher, который будет шифровать и
расшифровывать текст методом блочной перестановки с помощью текстового
ключа.
Основная идея:

1. Ключ — строка, состоящая из уникальных английских букв. Пример:
acb
2. Шифрование — алгоритм, который преобразует исходный текст в
набор зашифрованных символов.
3. Дешифрование — алгоритм, который преобразует набор
зашифрованных символов в исходный текст.

Ключ и его обработка:

• ключ состоит только из букв английского алфавита
• символы в ключе должны быть уникальны (регистр букв не имеет
значения — "A" и "a" считаются одинаковыми)
• ключ преобразуется в числовой массив. Каждому символу
присваивается его порядковый номер в алфавите (a = 0, b = 1, ..., z =
25)

Правила шифрования:

• исходный текст делится на блоки длины, равной длине ключа
• если длина блока не кратна длине ключа, то оставшийся блок
дополняется пробелами
• в каждом из блоков символы переставляются согласно порядку из
ключа

Пример алгоритма шифрования:
Ключ: "acb"
Текст: "helloworld"
Блоки: ["hel", "low", "orl", "d "]
Блоки после перестановки: ["hle", "lwo", "olr", "d "]
Результат: "hlelwoolrd "
Правила дешифрование:

• исходный порядок восстанавливает символы в каждом блоке
• лишние пробелы после дешифровки удаляются

Валидации и работа с ошибками:

• проверяется, что ключ состоит только из букв английского алфавита
• проверяется, что все буквы в ключе уникальны, игнорируя регистр
• если ключ не соответствует требованиям, вызывается исключение
ValueError с понятным сообщением об ошибке

Тесты для примеров и проверки:
Пример 1: Шифрование с явной итерацией по блокам
text = "HELLOWORLD"
key = "bAc"
print("Процесс шифрования по блокам:")
cipher = BlockTranspositionCipher(text, key)
for i, encrypted_block in enumerate(cipher, 1):
print(f"Блок {i}: '{encrypted_block}'")*

Пример 2: Полное шифрование
cipher = BlockTranspositionCipher(text, key)
encrypted = ''.join(cipher)
print(f"\nПолный зашифрованный текст: '{encrypted}'")
Пример 3: Дешифрование с итерацией
print("\nПроцесс дешифрования по блокам:")
decipher = BlockTranspositionCipher(encrypted, key, decrypt=True)
for i, decrypted_block in enumerate(decipher, 1):
print(f"Блок {i}: '{decrypted_block}'")
Пример 4: Полное дешифрование с обрезкой пробелов
decipher = BlockTranspositionCipher(encrypted, key, decrypt=True)
decrypted = ''.join(decipher)
print(f"\nПолный расшифрованный текст: '{decrypted}'")
'''

class BlockTranspositionCipher():
    def __init__(self, text, key, decrypt=False):
        self.text = text
        self.key = key
        self.encrypted = None
        self.decrypt = decrypt

    def __iter__(self):
        ...

    def __next__(self):
        ...